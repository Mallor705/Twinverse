diff --git a/.gitignore b/.gitignore
index 5f37f25..4593027 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,9 @@ __pycache__/
 *.so
 
 # Distribution / packaging
+build-dir/
+flatpak-repo/
+.flatpak-builder/
 AppDir/
 .Python/
 env/
@@ -78,3 +81,4 @@ relatorio_*
 *.lnk
 *.AppImage
 *.appimage
+*.flatpak
diff --git a/io.github.mallor.MultiScope.yaml b/io.github.mallor.MultiScope.yaml
index 304e6b8..6c7daf5 100644
--- a/io.github.mallor.MultiScope.yaml
+++ b/io.github.mallor.MultiScope.yaml
@@ -17,6 +17,9 @@ finish-args:
   # DBus for KDE integration
   - --socket=session-bus
   - --system-talk-name=org.freedesktop.login1
+  - --talk-name=org.freedesktop.Flatpak
+  - --talk-name=org.kde.KWin
+  - --talk-name=org.kde.plasmashell
 
   # Network (if needed)
   - --share=network
diff --git a/src/services/instance.py b/src/services/instance.py
index a8c766d..4b26784 100644
--- a/src/services/instance.py
+++ b/src/services/instance.py
@@ -30,8 +30,14 @@ class InstanceService:
         self._virtual_joystick_path: Optional[str] = None
         self._virtual_joystick_checked: bool = False
         self.pids: dict[int, int] = {}
+        self.pgids: dict[int, int] = {}
         self.processes: dict[int, subprocess.Popen] = {}
         self.termination_in_progress = False
+        self.is_flatpak = self._is_flatpak()
+
+    def _is_flatpak(self) -> bool:
+        """Checks if the application is running inside a Flatpak."""
+        return os.path.exists("/.flatpak-info")
 
     def validate_dependencies(self, use_gamescope: bool = True) -> None:
         """Validates if all necessary commands are available on the system."""
@@ -39,9 +45,20 @@ class InstanceService:
         required_commands = ["bwrap", "steam"]
         if use_gamescope:
             required_commands.insert(0, "gamescope")
-        for cmd in required_commands:
-            if not shutil.which(cmd):
-                raise DependencyError(f"Required command '{cmd}' not found")
+
+        for cmd_name in required_commands:
+            # If in Flatpak, check on the host. Otherwise, check locally.
+            if self.is_flatpak:
+                check_cmd = ["flatpak-spawn", "--host", "which", cmd_name]
+                try:
+                    # We check the return code. A non-zero indicates the command is not found.
+                    subprocess.run(check_cmd, check=True, capture_output=True)
+                except subprocess.CalledProcessError:
+                    raise DependencyError(f"Required command '{cmd_name}' not found on the host system")
+            else:
+                if not shutil.which(cmd_name):
+                    raise DependencyError(f"Required command '{cmd_name}' not found")
+
         self.logger.info("Dependencies validated successfully")
 
     def _launch_single_instance(self, profile: Profile, instance_num: int) -> None:
@@ -52,11 +69,8 @@ class InstanceService:
         home_path.mkdir(parents=True, exist_ok=True)
         self.logger.info(f"Instance {instance_num}: Using isolated home path '{home_path}'")
 
-        # Prepare minimal home structure - Steam will auto-install on first run
         self._prepare_home(home_path)
-
         device_info = self._validate_input_devices(profile, instance_num, instance_num)
-
         env = self._prepare_environment(profile, device_info, instance_num)
 
         cmd_builder = CommandBuilder(
@@ -70,22 +84,52 @@ class InstanceService:
         )
         cmd = cmd_builder.build_command()
 
+        # If running in Flatpak, use an inline script to launch on the host
+        if self.is_flatpak:
+            escaped_cmd = " ".join(shlex.quote(c) for c in cmd)
+            inline_script = f"""
+                set -m; 
+                {escaped_cmd} & 
+                PID=$!; 
+                PGID=$(ps -o pgid= -p $PID | tr -d ' '); 
+                echo $PGID; 
+                fg %1;
+            """
+            cmd = ["flatpak-spawn", "--host", "bash", "-c", inline_script]
+
         log_file = Config.LOG_DIR / f"steam_instance_{instance_num}.log"
         self.logger.info(f"Launching instance {instance_num} (Log: {log_file})")
         self.logger.info(f"Instance {instance_num}: Full command: {shlex.join(cmd)}")
 
         try:
+            # For Flatpak, we need to capture stdout to get the PGID
+            stdout_pipe = subprocess.PIPE if self.is_flatpak else subprocess.DEVNULL
+            
             process = subprocess.Popen(
                 cmd,
-                stdout=subprocess.DEVNULL,
+                stdout=stdout_pipe,
                 stderr=subprocess.DEVNULL,
                 env=env,
-                cwd=Path.home(),  # Launch from the user's real home directory
-                preexec_fn=os.setpgrp,
+                cwd=Path.home(),
+                preexec_fn=os.setpgrp if not self.is_flatpak else None,
             )
+
+            if self.is_flatpak:
+                # Read the PGID from the host-launcher script
+                try:
+                    pgid_line = process.stdout.readline().decode().strip()
+                    self.pgids[instance_num] = int(pgid_line)
+                    self.logger.info(f"Instance {instance_num} started on host with PGID: {self.pgids[instance_num]}")
+                except (ValueError, IndexError) as e:
+                    self.logger.error(f"Failed to parse PGID for instance {instance_num}: {e}")
+                    raise
+            else:
+                self.pgids[instance_num] = os.getpgid(process.pid)
+            
             self.pids[instance_num] = process.pid
             self.processes[instance_num] = process
             self.logger.info(f"Instance {instance_num} started with PID: {process.pid}")
+
         except Exception as e:
             self.logger.error(f"Failed to launch instance {instance_num}: {e}")
 
@@ -137,28 +181,34 @@ class InstanceService:
             return
 
         process = self.processes[instance_num]
-        self.logger.info(f"Terminating instance {process}...")
+        self.logger.info(f"Terminating instance {process.pid}...")
+        
         if process.poll() is None:
+            pgid = self.pgids.get(instance_num)
+            if pgid:
+                if self.is_flatpak:
+                    self.logger.info(f"Sending SIGTERM to host process group {pgid} for instance {instance_num}")
+                    subprocess.run(["flatpak-spawn", "--host", "kill", "-s", "SIGTERM", f"-{pgid}"])
+                else:
+                    try:
+                        self.logger.info(f"Sending SIGTERM to process group {pgid} for instance {instance_num}")
+                        os.killpg(pgid, signal.SIGTERM)
+                    except ProcessLookupError:
+                        self.logger.info(f"Process group for PID {process.pid} not found for instance {instance_num}.")
+
             try:
-                pgid = os.getpgid(process.pid)
-                self.logger.info(f"Sending SIGTERM to process group {pgid} for instance {instance_num}")
-                os.killpg(pgid, signal.SIGTERM)
                 process.wait(timeout=10)
                 self.logger.info(f"Instance {instance_num} terminated gracefully.")
-            except ProcessLookupError:
-                self.logger.info(f"Process group for PID {process.pid} not found for instance {instance_num}.")
             except subprocess.TimeoutExpired:
                 self.logger.warning(f"Instance {instance_num} did not terminate after 10s. Sending SIGKILL.")
-                try:
-                    pgid = os.getpgid(process.pid)
-                    os.killpg(pgid, signal.SIGKILL)
-                    self.logger.info(f"Sent SIGKILL to process group {pgid} for instance {instance_num}")
-                except ProcessLookupError:
-                    self.logger.info(f"Process group for PID {process.pid} not found when sending SIGKILL.")
-                except Exception as e:
-                    self.logger.error(f"Failed to kill process group for PID {process.pid}: {e}")
-            except Exception as e:
-                self.logger.error(f"An unexpected error occurred during termination for instance {instance_num}: {e}")
+                if pgid:
+                    if self.is_flatpak:
+                        subprocess.run(["flatpak-spawn", "--host", "kill", "-s", "SIGKILL", f"-{pgid}"])
+                    else:
+                        try:
+                            os.killpg(pgid, signal.SIGKILL)
+                        except ProcessLookupError:
+                            self.logger.info(f"Process group for PID {process.pid} not found when sending SIGKILL.")
 
         if process.poll() is None:
             process.wait()
@@ -167,6 +217,8 @@ class InstanceService:
             del self.processes[instance_num]
         if instance_num in self.pids:
             del self.pids[instance_num]
+        if instance_num in self.pgids:
+            del self.pgids[instance_num]
 
 
     def _prepare_home(self, home_path: Path) -> None:
diff --git a/src/services/kde_manager.py b/src/services/kde_manager.py
index 7cbf6e8..11a7323 100644
--- a/src/services/kde_manager.py
+++ b/src/services/kde_manager.py
@@ -10,8 +10,13 @@ class KdeManager:
     def __init__(self, logger: Logger):
         self.logger = logger
         self.original_panel_states = {}
-        self.qdbus_command = self._find_qdbus_command()
         self.kwin_script_id = None
+        try:
+            self.bus = pydbus.SessionBus()
+            self.plasma_shell = self.bus.get("org.kde.plasmashell", "/PlasmaShell")
+        except Exception as e:
+            self.logger.warning(f"Could not connect to Plasma Shell via D-Bus: {e}")
+            self.plasma_shell = None
 
     def start_kwin_script(self, profile: Profile):
         """
@@ -83,51 +88,41 @@ class KdeManager:
 
     def is_kde_desktop(self):
         """Check if the current desktop environment is KDE."""
-        return os.environ.get("XDG_CURRENT_DESKTOP") == "KDE"
+        return "KDE" in os.environ.get("XDG_CURRENT_DESKTOP", "")
 
-    def _find_qdbus_command(self):
-        """Find the correct qdbus command (qdbus or qdbus6)."""
-        for cmd in ["qdbus6", "qdbus"]:
-            try:
-                subprocess.run([cmd, "--version"], capture_output=True, check=True)
-                self.logger.info(f"Using '{cmd}' for dbus communication.")
-                return cmd
-            except (subprocess.CalledProcessError, FileNotFoundError):
-                continue
-        self.logger.warning("Neither 'qdbus' nor 'qdbus6' command found.")
-        return None
-
-    def _run_qdbus_script(self, script):
-        """Run a Plasma Shell script using the detected qdbus command."""
-        if not self.qdbus_command:
+    def _run_plasma_script(self, script):
+        """Run a Plasma Shell script using pydbus."""
+        if not self.plasma_shell:
+            self.logger.warning("Plasma Shell D-Bus service not available.")
             return None
         try:
-            command = [
-                self.qdbus_command,
-                "org.kde.plasmashell",
-                "/PlasmaShell",
-                "org.kde.PlasmaShell.evaluateScript",
-                script,
-            ]
-            result = subprocess.run(command, capture_output=True, text=True, check=True)
-            return result.stdout.strip()
-        except subprocess.CalledProcessError as e:
-            self.logger.error(f"Error executing qdbus script: {e}")
-            self.logger.error(f"Stderr: {e.stderr}")
-            return None
-        except FileNotFoundError:
-            self.logger.error(f"'{self.qdbus_command}' not found.")
+            # The result from evaluateScript is often a string representation of the output,
+            # which might be empty or require parsing.
+            result = self.plasma_shell.evaluateScript(script)
+            # pydbus might return the value directly, so we handle it as such.
+            # If it's a string, we might need to strip trailing newlines.
+            if isinstance(result, str):
+                return result.strip()
+            return result
+        except Exception as e:
+            self.logger.error(f"Error executing Plasma script via D-Bus: {e}")
             return None
 
     def get_panel_count(self):
         """Get the number of panels."""
         script = "print(panels().length)"
-        count_str = self._run_qdbus_script(script)
-        return int(count_str) if count_str and count_str.isdigit() else 0
+        count = self._run_plasma_script(script)
+        # The script `print(panels().length)` returns a string like "2\n".
+        # We need to handle this to get an integer.
+        try:
+            return int(str(count).strip())
+        except (ValueError, TypeError):
+            self.logger.error(f"Could not parse panel count from: {count}")
+            return 0
 
     def save_panel_states(self):
         """Save the current visibility state of all panels."""
-        if not self.is_kde_desktop() or not self.qdbus_command:
+        if not self.is_kde_desktop() or not self.plasma_shell:
             return
 
         panel_count = self.get_panel_count()
@@ -138,31 +133,31 @@ class KdeManager:
         self.original_panel_states = {}
         for i in range(panel_count):
             script = f"print(panels()[{i}].hiding)"
-            state = self._run_qdbus_script(script)
+            state = self._run_plasma_script(script)
             if state is not None:
                 self.original_panel_states[i] = state
                 self.logger.info(f"Saved panel {i} state: {state}")
 
     def set_panels_dodge_windows(self):
         """Set all panels to 'Dodge Windows' visibility."""
-        if not self.is_kde_desktop() or not self.qdbus_command:
+        if not self.is_kde_desktop() or not self.plasma_shell:
             return
 
         panel_count = self.get_panel_count()
         for i in range(panel_count):
             script = f"panels()[{i}].hiding = 'dodgewindows'"
-            self._run_qdbus_script(script)
+            self._run_plasma_script(script)
             self.logger.info(f"Set panel {i} to 'Dodge Windows'")
 
     def restore_panel_states(self):
         """Restore the visibility state of all panels to their original state."""
-        if not self.is_kde_desktop() or not self.qdbus_command or not self.original_panel_states:
+        if not self.is_kde_desktop() or not self.plasma_shell or not self.original_panel_states:
             return
 
         for i, state in self.original_panel_states.items():
             # The 'null' state needs to be handled as a special case
             script_state = f"'{state}'" if state != "null" else "null"
             script = f"panels()[{i}].hiding = {script_state}"
-            self._run_qdbus_script(script)
+            self._run_plasma_script(script)
             self.logger.info(f"Restored panel {i} to state: {state}")
         self.original_panel_states = {}
